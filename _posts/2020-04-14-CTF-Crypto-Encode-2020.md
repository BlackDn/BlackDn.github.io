---
layout:       post  
title:        CTF-加解密及常见编码
subtitle:     内含常用的编码解码在线工具
date:         2020-04-14  
auther:       BlackDn  
header-img:   img/acg.gy_26.jpg
catalog:      true  
tags:  
    - CTF  
---

> "长夜无眠，为海祈梦。星海横流，岁月成胧。"

# 前言
找时间一点点看了各种编码，然后写个总结  
少说几百种头嗡嗡大，所以介绍一下常见的  
剩下的...遇到了再说吧...  

# 加解密及常见编码
## 常见编码
网络传输中常用的加密编码
### 1. Unicode
众所周知ASCII码用一个字节表示一个字符，但是表示不了中文（和除了英语的其他语言）于是提出Unicode，用两个字节表示一个字符。原本的英文字符（ASCII码）就在高位加0  
包含UTF-8（以8位为一个编码单位的可变长编码），UTF-16（16位），UTF-32等  

Unicode编码有以下四种编码方式：（源文本：The）  

1. &#x [Hex]：&#x0054；&#x0068；&#x0065；
2. &# [Decimal]：&#00084；&#00104；&#00101
3. \U [Hex]：\U0054\U0068\U0065
4. \U+ [Hex]：\U+0054\U+0068\U+0065

### 2. Escape编码/Unescape解码
Escape编码：又叫%u编码，采用UTF-16BE模式， Escape编码/加密,就是字符对应UTF-16，16进制表示方式前面加%u  
Unescape解码：去掉"%u"后，将16进制字符还原后，由utf-16转码到自己目标字符  
**特点：%xxxx(xxxx等于UTF-16对应十六进制编码)**

```
文本： The
Escape编码：%u0054%u0068%u0065
```
### 3. URL编码
url编码又叫百分号编码，是统一资源定位(URL)编码方式。除了常用字母数字，url地址中其它字符通过%xx编码处理  
在ascii码的的16进制字符前面加%  

```
“\” => %5c （“\”的ascii码是92，92的十六进制是5c）
你好 => %E4%BD%A0%E5%A5%BD
```
### 4. base编码
 Base家族主要有Base16、Base32、Base64。  
#### base64
对二进制数据以6个位(bit)为一组切分，所以分切之前的二进制位数应该是24的倍数（即6，8的最小公倍数）。如果不足24位,则在编码后数据后面添加"="    
**特征：由64个字符(A-Z,a-z,0-9,+,/)组成，末尾可能会出现1或2个’=’ 最多有2个**  

| 数值 | 字符 | 数值 | 字符 | 数值 | 字符 | 数值 | 字符 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 0    | A    | 16   | Q    | 32   | g    | 48   | w    |
| 1    | B    | 17   | R    | 33   | h    | 49   | x    |
| 2    | C    | 18   | S    | 34   | i    | 50   | y    |
| 3    | D    | 19   | T    | 35   | j    | 51   | z    |
| 4    | E    | 20   | U    | 36   | k    | 52   | 0    |
| 5    | F    | 21   | V    | 37   | l    | 53   | 1    |
| 6    | G    | 22   | W    | 38   | m    | 54   | 2    |
| 7    | H    | 23   | X    | 39   | n    | 55   | 3    |
| 8    | I    | 24   | Y    | 40   | o    | 56   | 4    |
| 9    | J    | 25   | Z    | 41   | p    | 57   | 5    |
| 10   | K    | 26   | a    | 42   | q    | 58   | 6    |
| 11   | L    | 27   | b    | 43   | r    | 59   | 7    |
| 12   | M    | 28   | c    | 44   | s    | 60   | 8    |
| 13   | N    | 29   | d    | 45   | t    | 61   | 9    |
| 14   | O    | 30   | e    | 46   | u    | 62   | +    |
| 15   | P    | 31   | f    | 47   | v    | 63   | /    |

1. 数据编码转为二进制，5个位为一组，转为十进制
2. 将十进制转为编码表中对应字符
3. 不足24位,则在编码后数据后面添加"="，相当于6个位  

```
文本：    ILU
ASCII编码：73    76    85
二进制：010010|01    0100|1100    01|010101
十进制：18|20|49|21
Base64编码：SUxV
```
#### base32
对二进制数据以5个位(bit)为一组进行切分，由于传输数据的单位是字节（即8个位），所以分割之前的二进制位数是40的倍数（40是5和8的最小公倍数）。如果不足40位，则在编码后数据补充"="，一个"="相当于一个组（5个位）
**特征：密文由32个字符（A-Z,2-7)组成，末尾可能会有‘=’，但最多有6个**  

| 数值 | 字符 | 数值 | 字符 | 数值 | 字符 | 数值 | 字符 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 0   | A   | 8   | I    | 16   | Q    | 24   | Y    |
| 1    | B    | 9   | J    | 17   | R    | 25   | Z    |
| 2    | C   | 10   | K    | 18   | S    | 26   | 2    |
| 3   | D   | 11   | L    | 19   | T    | 27   | 3    |
| 4    | E   | 12  | M    | 20   | U    | 28   | 4    |
| 5    | F   | 13   | N    | 21   | V    | 29   | 5    |
| 6    | G   | 14   | O    | 22   | W    | 30   | 6    |
| 7    | H   | 15   | P    | 23   | X    | 31   | 7    |
| 填充 | =    |     |     |     |     |     |     |

1. 数据编码转为二进制，5个位为一组，转为十进制
2. 将十进制转为编码表中对应字符
3. 若不足40的倍数，添加“=”相当于一个组（5个位），编码后的数据是原先8/5倍

```
文本：    ILU
ASCII编码：73    76    85
二进制：01001|001    01|00110|0    0101|0101
十进制：9|5|6|5|10 
Base32编码：JFGDK===
```
#### base16
将ASCII字符集中可打印的字符(0-9A-F)对应的二进制字节数据进行编码  
（base16编码表其实就是0-9A-F）  
**特征：密文由16个字符（0-9，A-F）组成**  

1. 将数据（根据ASCII编码，UTF-8编码等）转成二进制数，不足8比特位高位补0。然后将所有的二进制全部串起来，4个位为一组，转化成十进制数
2. 根据十进制数值找到Base16编码表里面对应的字符
3. 因为ASCII码用一个字节表示一个字符，base16采用4位分组。若原数据采用ASCII编码，每个字符都被编码为两个字符，数据量变为原来两倍  

```
文本：    ILU
ASCII编码：73    76    85
二进制：0100|1001    0100|1100    0101|0101
十进制：4|9    4|12    5|5
Base16编码：4 9 4 C 5 5
```
### 5. UUencode编码
将二进制文件转换为文本文件  

1. 将数据每三字节为一组（24bit），每组重新以6bit分为四组
2. 将6bit的二进制转为十进制，数值在0-63间，每个再加上32，结果在32-95间（ASCII中32-空格，95-底线），实现二进制到文本符号转换
3. 最后部分少于三个字节，用零补齐
4. 每60个编码输出（相当于45个输入字节）将输出为独立的一行，在每行的开头加上长度字符。除最后一行外，长度字符都应该是M（M的ASCII=77=32+45）  

```
文本：(长度为3)Cat
ASCII编码：67    97    116
二进制：010000|11    0110|0001    01|110100
十进制：（3）16|54|5|52  
+32：（35）48|86|37|84
UUencode编码：#0V%T
```
### 6. XXencode编码
和UUencode类似，也是把每三字节24bit的数据分为四组6bit，然后转为十进制  
每行的长度字符定义也相似  
唯一的不同是不+32，而采用自己的编码表  
跟base64编码表符相比，就是多一个“-” 字符，少一个”/” 字符  

| 数值 | 字符 | 数值 | 字符 | 数值 | 字符 | 数值 | 字符 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 0    | +    | 16   | E    | 32   | U    | 48   | k    |
| 1    | -    | 17   | F    | 33   | V    | 49   | l    |
| 2    | 0    | 18   | G    | 34   | W    | 50   | m    |
| 3    | 1    | 19   | H    | 35   | X    | 51   | n    |
| 4    | 2    | 20   | I    | 36   | Y    | 52   | o    |
| 5    | 3    | 21   | J    | 37   | Z    | 53   | p    |
| 6    | 4    | 22   | K    | 38   | a    | 54   | q    |
| 7    | 5    | 23   | L    | 39   | b    | 55   | r    |
| 8    | 6    | 24   | M    | 40   | c    | 56   | s    |
| 9    | 7    | 25   | N    | 41   | d    | 57   | t    |
| 10   | 8    | 26   | O    | 42   | e    | 58   | u    |
| 11   | 9    | 27   | P    | 43   | f    | 59   | v    |
| 12   | A    | 28   | Q    | 44   | g    | 60   | w    |
| 13   | B    | 29   | R    | 45   | h    | 61   | x    |
| 14   | C    | 30   | S    | 46   | i    | 62   | y    |
| 15   | D    | 31   | T    | 47   | j    | 63   | z    |

```
文本：（长度为3）Cat
ASCII编码：67    97    116
二进制：010000|11    0110|0001    01|110100
十进制：（3）16|54|5|52  
XXencode编码：1Eq3o
```
### 6. MD5
MD5信息摘要算法，它将源的字符串通过哈希函数转换为特定长度的字符串  
MD5编码具有单向性，即由明文变密文简单，由密文变明文困难。基于这个特性，MD5可以有效保证信息的完整性，常用于验证数据是否被篡改  

1. MD5码以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由4个32位分组组成，并级联后将生成一个128位散列值。
2. 继续向后取512位数据，不够则进行填充。每次的运算都由前一轮的128位散列值和当前的512bit值进行运算
3. 因此MD5结果值是一段固定长度的数据，无论原始数据是多长或多短，其MD5值都是128bit
4. 最后按十六进制计算输出，即结果为0-9a-f

### 7. SHA
安全散列算法（Secure Hash Algorithm），是一个密码散列函数家族。能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法  
SHA-0 -> SHA-1 -> SHA -2：包括SHA-224、SHA-256、SHA-384 和 SHA-512等  
SHA1的原始报文长度不能超过2的64次方，SHA1生成160位的报文摘要  
SHA得到摘要的方法和MD5思想类似，将数据分组后后面的组利用前面的组进行计算处理，最后一个组得到结果摘要

```
SHA-1算法
1. 对源数据以512bit为一组进行分组，以abc为例  
（a-97, b-98, c-99）得到源数据：01100001 01100010 01100011
2. 不足则补位，使长度对512求余为448，填充的最高位补1，其余补0。随后转为十六进制  
初始：01100001 01100010 01100011
补位：01100001 01100010 01100011 100...0（423个0）
十六进制：
61626380 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000
3. 附加长度值，在信息摘要后面附加 64 Bits 的信息，用来表示原始信息摘要的长度。这一步执行完毕后信息报文便是 512 Bits 的倍数  
abc占3字节，即24位 ，换算为十六进制即为 0x18  
61626380 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000018
4. 初始化缓存。一个 160 位 MD 缓冲区用以保存中间和最终散列函数的结果。它可以表示为 5 个 32 位的寄存器
5. 一顿操作计算，最后将五个寄存器内容连接得出结果
```
  
```
SHA-256算法
1. 填充附加位  
和SHA-1类似，对报文进行填充使报文长度与 448 模 512 同余（长度 = 448 mod 512）  
填充比特串的最高位为1，其余位为0，直到长度满足 mod 512=448  
2. 附加长度值
和SHA-1基本一致，将填充前的报文位长度填充在低位，共64位，至此数据达到512位  
3. 初始化缓存
4. 处理分组计算输出，对所有512位分组处理完毕后，最后一个分组产生的便是25 位报文摘要
```

## 文本加密
主要是那些不在网络中用到的加密编码，包含一些古典密码和奇奇怪怪的加密方法
### 1. 凯撒密码
一种替换加密，明文中的所有字母都在字母表上向后（或向前）偏移固定位数后被替换成密文  
比如当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推  

```
偏移量：1
明文：The quick brown fox jumps over the lazy dog
密文：Uif rvjdl cspxo gpy kvnqt pwfs uif mbaz eph
```
### 2. 栅栏密码
栅栏密码(Rail-fence Cipher)，把要加密的明文分成N个一组，然后把每组的第1个字符组合，每组第2个字符组合...每组的第N(最后一个分组可能不足N个)个字符组合  

```
2栏栅栏加密
明文：The quick brown fox jumps over the lazy dog
去空格：Th|eq|ui|ck|br|ow|nf|ox|ju|mp|so|ve|rt|he|la|zy|do|g
第一组：Teucbonojmsvrhlzdg
第二组：hqikrwfxupoeteayo
密文：Teucbonojmsvrhlzdghqikrwfxupoeteayo
```
## 代码混淆
码混淆(Obfuscated code)，亦称花指令，是将计算机程序的代码转换成一种功能等价，但是难于阅读的形式的行为。代码混淆可以用于程序源代码，也可以用于程序编译而成的中间代码。  
### 1. Brainfuck
Brainfuck是一种极小化的计算机语言  

```
字符集（共八个字符）：
> < + – . , [ ]
```
### 2. Ook！
是由David Morgan-Mar创建的一个~~玩笑~~深奥的编程语言  
实际上是将Brainfuk用各种Ook和比哦哎单符号表示  

| Brainfuck |   Ook!   |
| --------- | -------- |
| >         | Ook.Ook? |
| <         | Ook?Ook. |
| +         | Ook.Ook. |
| -         | Ook!Ook! |
| .         | Ook!Ook. |
| ,         | Ook.Ook! |
| \[        | Ook!Ook? |
| \]        | Ook?Ook! |

### 3. JSfuck
jsfuck源于brainfuck，只用 6 个字符来编写 JavaScript 程序  
通常可用浏览器的console运行  

```
字符集：
[ ]( ) ! + 
```
#### 4. Jother
运用于JS语言，利用少量字符构造精简匿名函数方法对字符串进行编码操作，即javascript中使用少量特定字符对匿名函数进行编码加密  
通常可用浏览器的console运行  

```
特定字符包：
+ ! ( ) [ ] { }
```
## 信息传递
那些靠媒介传递文本信息的方法
### 1. 莫尔斯电码
时通时断的且通过不同的排列顺序来表达不同英文字母、数字和标点符号的信号代码  
**不能区分大小写**  
主要由以下5种它的代码组成：  

1. 点（.）
2. 划（-）
3. 每个字符间短的停顿（通常用空格表示停顿）
4. 每个词之间中等的停顿（通常用/划分）
5. 句子之间长的停顿


```
编码表：
A  .-    N  -.    .  .-.-.-  +  .-.-.    1  .----
B  -...  O  ---   ,  --..--  _  ..--.-   2  ..---
C  -.-.  P  .--.  :  ---...  $  ...-..-  3  ...--
D  -..   Q  --.-  "  .-..-.  &  .-...    4  ....-
E  .     R  .-.   '  .----.  /  -..-.    5  .....
F  ..-.  S  ...   !  -.-.--              6  -....
G  --.   T  -     ?  ..--..              7  --...
H  ....  U  ..-   @  .--.-.              8  ---..
I  ..    V  ...-  -  -....-              9  ----.
J  .---  W  .--   ;  -.-.-.              0  -----
K  -.-   X  -..-  (  -.--.    
L  .-..  Y  -.--  )  -.--.-          
M  --    Z  --..  =  -...- 
```
### 2. 敲击码
通过使用一系列的点击声音来编码  
敲击码是基于5×5方格波利比奥斯方阵来实现的，不同点是是用K字母被整合到C中  
**同样不能区分大小写**  

```
   1  2  3  4  5
  --------------
1| A  B C/K D  E
2| F  G  H  I  J 
3| L  M  N  O  P
4| Q  R  S  T  U
5| V  W  X  Y  Z
```

```
文本：F O X
位置：2,1    3,4    5,3
敲击码：..  .    ...  ....    ......  ...
```
## 参考
[ctf常见的编码](https://blog.csdn.net/weixin_44255856/article/details/89792997)  
[CTF中常见的编码，代码混淆及加、解密 ](https://www.freebuf.com/column/202057.html)  
[Base16,Base32,Base64编码的介绍](https://blog.csdn.net/lili13897741554/article/details/82177472)  
[CTF中那些脑洞大开的编码和加密](https://www.cnblogs.com/daban/p/5680451.html)  
[jother编码](https://blog.csdn.net/greyfreedom/article/details/45070667)  
[SHA 算法简介](https://www.jianshu.com/p/d3e8c5b521e1)  
