
---
layout: post
title: TCP/IP五层模型及协议    
subtitle: 顺便和OSI七层模型简单比较一下，介绍了一些常见协议   
date: 2023-09-19  
auther: BlackDn  
header-img: img/21mon8_23.jpg  
catalog: true  
tags:  
  -  Network  
---

> "沿路花事轻浮，归途断井颓垣。"。

# TCP/IP五层模型及协议

## 前言

好消息：好久没写文章了，上一篇文章竟是4个月之前的=。=  
坏消息：没想到一写就写了这么长，都快1w4的字了=。=  
不过这也没办法嘛，这种纯理论的文章就是会冗长点咧  
从网络模型入手，过了一遍五层的架构和其中常见的协议  
算是对计算机网络课的补票吧。  

## 网络模型

网络模型至今并没有一个“官方”的统一定论，不同的组织或企业（如ISO或思科等）都有不同的定义（甚至自己的模型还可以申请专利），但最常见是这两种：**OSI七层模型**和**TCP/IP五层模型**

### OSI七层模型

OSI模型，即**开放式系统互联模型（Open System Interconnection Model）**，是国际标准化组织（ISO）提出的世界范围内网络互联框架。

| 网络层级 | 层级名称   | 主要协议          |
| -------- | ---------- | ----------------- |
| 7        | 应用层     | HTTP, SMTP, FTP   |
| 6        | 表示层     | Telnet, SNMP      |
| 5        | 会话层     | SMTP, DNS         |
| 4        | 传输层     | TCP/UDP           |
| 3        | 网络层     | IP, BGP                |
| 2        | 数据链路层 | Ethernet, PPP   |
| 1        | 物理层     | IEEE 802.11 |

1. 物理层（Physical Layer）：负责传输比特流，在局域网上发送**数据帧（Frame）**，还包括与计算机互连的**物理设备**，如网线、光缆、交换机、路由器等。
2. 数据链路层（Data Link Layer）：负责将数据**封装成帧（Frame）**、错误检测和纠正、进行物理地址（MAC）的寻址。可以再细分为**逻辑链路控制层（logical link control，LLC）** 和**介质访问控层（Media access control，MAC）** 。
3. 网络层（Internet / Network Layer）：负责在网络中寻址和路由，将数据从源节点传输到目标节点。也叫网络互联层。
4. 传输层（Transport Layer）：负责提供可靠的端到端数据传输，包括数据分段、流量控制和错误恢复等功能。和网络层（IP协议）有些许类似，不同点在于TCP/UDP协议负责确保数据被节点上的**特定应用**获取，因此层级更高。
5. 会话层（Session Layer）：负责建立、管理和终止会话连接，维护两台计算机之间的通信连接以实现通信和数据交换。
6. 表示层（Presentation Layer）：负责数据的格式转换、编码和加解密，以确保不同系统之间的数据兼容性，将数据转为适合传输的格式。
7. 应用层（Application Layer）：提供用户（应用程序）与网络之间的接口，即基于应用程序的数据传输服务，对应用程序所需的功能进行抽象和封装。

值得注意的是，OSI模型在学术界和标准化组织中更为常见（可能因此上学的时候会着重学习），用于理论讨论和规范制定，**教育意义和学术意义较高，但并没有被广泛应用于实际的网络工程和配置**。  
它的好处是将网络连接分了七层，非常细致。坏处是太细致了，在现实中使用需要较高系统设计和维护成本。因此现实中更多使用**TCP/IP五层模型**
### TCP/IP五层模型

**TCP/IP五层模型**是一种更简化、更专注于TCP/IP协议的模型，在现实中更常见，更贴近实际的互联网通信。  
需要声明的一点，这个模型之所以叫**TCP/IP**，并非其只包含这两种协议，而是这两个协议是整个模型中最早通过的标准，也是最为广泛使用的协议。也可以将其视为**简化的OSI七层模型**。  
严格来说，它应该叫**TCP/IP协议族（TCP/IP Protocol Suite）**，而其上下分层的结构类似堆栈，因此也称**TCP/IP协议栈（TCP/IP Protocol Stack）**  
具体层级如下：

| 网络层级 | 层级名称   | 主要协议      | 数据单元         | 地址 |
| -------- | ---------- | ------------- | ---------------- | ---- |
| 5        | 应用层     | HTTP, SMTP    | Message          | n/a  |
| 4        | 传输层     | TCP/UDP       | Segment/Datagram | Port |
| 3        | 网络层     | IP, BGP            | Packet           | IP   |
| 2        | 数据链路层 | Ethernet, PPP | Frame            | Mac  |
| 1        | 物理层     | IEEE 802.11   | Bit              | n/a  |

TCP/IP五层模型的每个层级的作用和OSI模型的差不多，就不多赘述了。它将OSI模型的**上三层（应用层、表示层、会话层）合并为应用层**，负责两台计算机（的某两个应用程序）之间的传输。  
其实也挺合理的，毕竟在OSI模型中，会话层用于建立、管理和终止两台计算机的会话连接；表示层用于数据的格式转换，以便当前应用程序可以接收读取数据；应用层则是应用程序与网络之间的接口的封装。他们的主体都是应用程序本身。

也就是说，在**TCP/IP五层模型**中，我们把两个应用程序之间的数据交换抽象为最高的一个层级（应用层），至于应用程序是怎么打包解包数据、数据是怎么在网络中传输的，就交给下面的层级去处理了。

### 模型层级对比

这里列个表简单比较一下几个模型，除了**OSI七层模型**和**TCP/IP五层模型**之外，再放一个**TCP/IP四层模型**进来

| OSI七层模型 | TCP/IP五层模型 | TCP/IP四层模型 | 对应层级协议               |
| ----------- | -------------- | -------------- | -------------------------- |
| 应用层      | 应用层         | 应用层         | HTTP, DNS, FTP, SMTP, SNMP |
| 表示层      |                |                | Telnet, SNMP, SSL/TLS,     |
| 会话层      |                |                | NetBIOS, RPC               |
| 传输层      | 传输层         | 传输层         | TCP, UDP                   |
| 网络层      | 网络层         | 网络层         | IP, ICMP, BGP              |
| 数据链路层  | 数据链路层     | 数据链路层     | Ethernet, PPP, HDLC        | 
| 物理层      | 物理层         |                | Ethernet, USB, HDMI        |

**TCP/IP四层模型**在五层模型的基础上进一步简化，合并**数据链路层**和**物理层**为数据链路层，有时也称**网络接口层**。

## TCP/IP五层模型的具体层级

### 物理层（和一些相关设备）

这里主要是一些物理设备，看过留个印象就好了。

#### 电缆（Cables）

电缆将不用设备在现实中连接在一起，允许他们互相交换数据，可分为：

- 铜缆：即我们用的**网线**，要注意的是一条网线其实含有很多对绞合的铜线（不信把你的网线剪开看看），根据不同标准可分为Cat5，Cat5e，Cat6等，即所谓的五类网线、超五类网线、六类网线等。不同标准的可用长度（信号随距离衰弱程度）和传输速率各不相同
- 光缆：由玻璃或塑料制成的可通过光传导信号的纤维，有着速度快、衰弱小的优点。\[注：禁止开挖国防光缆（误）\]

#### 交换机 （Switch）

此Switch非彼Switch（   
交换机是二层（数据链路层）的网络互联设备，含有多个接口以允许多台计算机连接到它，形成一个**局域网（LAN，Local Area Network）**。学校机房啥的用到的会比较多。  
交换机内部维护一个MAC寻址表，当某个端口被插上机子后，它会更新这个表，将机子的MAC地址和这个端口对应，这样交换机就知道收到的消息要从哪个端口转发了。  
此外，交换机还可以自己分割网段，形成若干个子局域网，即**虚拟局域网（VLAN，Virtual LAN）** 以此解决**冲突域**、**广播域**、**带宽不足**等问题

我记得上学的时候还做题来模拟交换机寻址呢，现在差不多都忘了=。=

#### 路由器（Router）

路由器是三层（网络层）设备，它可以连接多个网络，可以理解成它连接多个交换机/路由器（没错，可以路由器连路由器进行套娃）。  
它通过检测IP报文头部信息来判断将消息送到哪个网络，和交换机类似，它内部维护一个**路由表（Routing Table）** ，通过路由表可以判断报文传输的最佳路径（通过最少的节点来传递报文）。  
不同路由器之间通过**BGP（Border Gateway Protocol）协议**共享数据，使得路由器可以从多个可达路径中选择最优路径进行数据传递，同时可以确保网络不会因为某个路由器的单点故障而崩溃。

### 数据链路层

数据链路层实际上是对物理层的一个抽象，使得其他高层不用考虑物理层使用的硬件或设备有什么不同，以保证当物理设备发生更改时，网络层、传输层、应用层等仍以同样的方式工作。数据链路层的流量控制、错误检测和纠正等机制是实现**数据可靠传输**的关键。

#### 以太网协议（Ethernet）

Ethernet于1980年提出，于1983年成为标准。其是目前使用最广的数据链路层协议，被广泛应用于局域网（LAN）和广域网（WAN）中计算机和网络设备之间传输数据，定义了网络中采用的电缆类型及其信号处理方法。   
（电脑的网线接口通畅就叫以太网接口，可以在网络设置中看到）

#### 广播域、冲突域、CSMA/CD

- 广播域（Broadcast Domain）：指在网络中互相连接的一组设备。当其中一个设备发送广播消息时，同一广播域的所有设备都会收到该条消息。在以太网中，代表广播的MAC地址是`FF:FF:FF:FF:FF:FF`（全为1的地址）
  一个广播域可以包含多个交换机和多个网段，常被用来实现多播和广播通信，如ARP协议、DHCP协议等
- 冲突域（Collision Domain）：当一组设备共享同一物理介质（同轴电缆、双绞线等），可能有多个设备在物理介质中同时发送数据帧而引起碰撞。冲突域指的就是可能发生这些碰撞的范围。

在早期的**共享式以太网**中，由于多个机器连接在同一条同轴电缆上，当某台机器发送数据时，可能其他机器已经占用了该电缆，从而产生**冲突域**，使得数据发送失败。  
为了避免冲突域，现在的以太网采用**CSMA/CD（Carrier Sense Multiple Access With Collision Detection，载波侦听多路访问/冲突检测）** 来判断数据通道是否通畅、是否可以发送数据。

简单来说，CSMA/CD会检测当前网段上是否有数据传输，没有则发送，有则等待一个随机时间后再次尝试发送。此外，CSMA/CD使用MAC地址确认目标节点。  
即：先听后发、边听边发、冲突停发、随即延迟后发

CSMA/CD只是以太网处理冲突域的方式，其他协议则可能有其他的方法避免冲突域，即**介质访问控制**方法，比如CSMA/CA、轮询（Polling）、令牌传递（Token Passing）、

如今的以太网属于**交换式以太网**，通过交换机的检查机制，隔离冲突。一个交换机的接口及其连接的设备就是一个冲突域。

最后还有数据链路层的**差错控制**方法：奇偶校验、循环冗余校验（CRC）、循环冗余校验码（Hamming码）、海明距离检测、自动重传请求（ARQ）等。    
最最后还还有**流量控制**方法：停止等待协议（Stop-and-Wait Protocol）、后退N帧协议（Go-Back-N Protocol）、选择性重传协议（Selective Repeat Protocol）、滑动窗口协议（Sliding Window Protocol）等。  
（诶，我记得某个必修课期末考最后一道大题是滑动窗口，没写出来，笑死。）

#### MAC地址

**以太网卡（NIC，Network Interface Card）**，简称网卡，每个网卡都会关联一个MAC地址。  
**MAC（Media Access Control，媒体访问控制）** 是网卡的全局唯一标识，48位的二进制数，常用六组二位十六进制标识：`bc:d0:74:59:ed:08`  

可以在命令行输入` ipconfig /all`（Win）或者  `ifconfig`（Linux） 来查看当前设备物理地址（通常是eth0或wlan0，具体名称可能会有所不同）。每个计算机的MAC地址都是唯一的，用于在局域网中标识设备。  

在网络中，存在三种节点通信类型：
- 单播（Unicast，1对1）：一个节点单独给另一个节点发送数据
- 组播（Multicast，1对多）：一个节点给部分若干个节点发送数据
- 广播（Broadcast，1对全）：一个结对给全部节点发送数据
对此，MAC地址也分为单播MAC地址、组播MAC地址、广播MAC地址。  

对于单播MAC地址来说，前三组是生产商的组织唯⼀标识（OUI，Organizationally Unique Identifier），由 IEEE 分配给各个硬件制造商；后三位交给制造商自行安排，只要保持其唯一性就行。  
组播MAC地址的前三组不用于标识制造商，而是用于标识特定的多播组或协议。  
广播MAC地址就是预定义的`FF:FF:FF:FF:FF:FF`  


| 类型              | 模式     | 说明                                                                          |
| ----------------- | -------- | ----------------------------------------------------------------------------- |
| 单播（Unicast）   | 一对一   | MAC地址的第⼀组的后⼀个⼆进位为0，表示发送到某一个设备，如`00:1A:2B:3C:4D:5E` |
| 组播（Multicast） | 一对多   | MAC地址的第⼀组的后⼀个⼆进位为1，表示发送到某一组设备，如`01:1A:2B:3C:4D:5E` | 
| 广播（Broadcast） | 一对全部 | 目标地址为`FF:FF:FF:FF:FF:FF  `                                               |

### 网络层

（好家伙，又回想起被组网技术支配的恐惧） 
网络层的功能包括寻址和路由选择、连接的建立和终止等，它主要是为传输层服务，使得传输层不需要关心网络中的数据是如何传输和交换的。   

#### IP协议和IP报文

**IP协议（Internet Protocol）** 是互联网上最基本和最重要的协议之一（毕竟叫TCP/IP模型呢），它允许不同类型的计算机通过统一的网络进行通信，其具有路由寻址、定位、分包等功能。    
IP协议是**无连接**的协议，它不需要在发送数据之前建立连接，也不保证数据包的到达顺序和完整性，只负责尽最大努力地传送数据包。   
由于IP协议会将数据封装成IP报文，因此先来看看**IP报文结构（IPv4）**，大致可分为**IP报文头部**和**数据部分**。

![IPv4 Datagram Structure](https://z1.ax1x.com/2023/09/14/pPRqgO0.png)

- **版本（Version）**：长度4bit，代表IP协议版本，即IPv4或IPv6
- **头部长度（Header Length）**： 长度4bit，表示整个IP报文头部的长度（IPv4为20字节，IPv6为40字节）
- **服务类型（Service Type）**：长度8bit，用于指定数据包的服务质量和优先级
- **总长度（Total Length）**：长度16bit，表示整个报文的长度，包括头部和数据部分。
- **标识（Identification）**：长度16bit，数据包的唯一标识，用于消息的分片和重组。
- **标志（Flags）**：用于标识数据报⽂是否允许分段，或者标识数据报⽂已经分段
- **片偏移（Fragment Offset）**：表示分片前在原始数据包中的位置
- **生存时间（TTL，Time To Live）**：长度8bit，指定数据包在网络中的最大生存时间（其实是路由跳转的个数），以防止数据包在网络中丢失后占用流量。
- **协议（Protocol）**：长度8bit，表示使用哪个传输层协议（TCP、UDP或ICMP等）
- **头部校验和（Header Checksum）**：校验IP报文头部的完整性
- **源IP地址（Source IP Address）**：发送数据包的计算机IP地址
- **目标IP地址（Destination IP Address）**：接收数据包的计算机IP地址
- 可选部分：在IPv4中，IP报文可以包括可选部分，用于提供附加信息或选项，如记录路由、时间戳等。在IPv6中，可选部分已经被更灵活和可扩展的扩展报头所取代。

对于IPv4来说，其地址长度为32bit（4个字节Byte），理论上能支持约42亿个唯一的IPv4地址。不过由于地址耗尽问题，现在IPv6已经被设计和推广，以取代IPv4。IPv6采用了128位地址，提供了更大的地址空间，同时解决了一些IPv4的限制，不过咱还是从IPv4入手。

#### IPv4地址分类

在IPv4中，IP地址根据其**用途**和**网络规模**被分为A、B、C、D和E类地址。  
此外，IPv4 地址由**⽹络部分(Network)** 和**主机部分(Host)** 组成，网络部分相同的设备则处于同一⼦⽹下，这些设备可以不经过路由⽽连通彼此。

| 类型               | 范围                        | 描述                                                                      | （一个子网）最大主机数 |
| ------------------ | --------------------------- | ------------------------------------------------------------------------- | ---------------------- |
| A类地址（Class A） | 1.0.0.0 - 126.0.0.0         | A类地址用于大型网络，第一个字节用于网络标识，其余三个字节用于主机标识。   | 约16,777,214           |
| B类地址（Class B） | 128.0.0.0 - 191.255.0.0     | B类地址用于中型网络，前两个字节用于网络标识，后两个字节用于主机标识。     | 约65,534               |
| C类地址（Class C） | 192.0.0.0 - 223.255.255.0   | C类地址用于小型网络，前三个字节用于网络标识，最后一个字节用于主机标识。   | 约254                  |
| D类地址（Class D） | 224.0.0.0 - 239.255.255.255 | D类地址用于多播通信，不用于标识单个主机或网络。相当于全是子网，没有主机。 | -                      |
| E类地址（Class E） | 240.0.0.0 - 255.255.255.255 | E类地址保留供实验和特殊用途，不用于常规互联网通信。                       | -                       |

类别越靠前，能细分的子网数量越少（⽹络部分位数越少），但是一个子网所能含有的设备数量越多（主机部分位数越多）。    

要注意的是，有一些IP地址属于**预留地址**，不能分给网络设备（就好比编程语言里的关键字不能作为变量名）：
- **0.0.0.0**：代表所有网络
- **127.0.0.0 - 127.255.255.255**：用于主机内部循环测试和自我回环（Loopback）通信。比如`127.0.0.1`就是"localhost"。
- **255.255.255.255**：代表所有主机
- **网络地址**：⼀个⽹段中的第⼀个地址称为⽹络地址，⽤于标识⼀个⽹络，不能分配给主机。比如对于网段`10.1.10.0/24`来说，`10.1.10.0` 是⽹络地址
- **广播地址**：⼀个⽹段中的最后一个地址称为⽹络地址，⽤于向该⽹络中所有主机发送数据的。比如对于网段`10.1.10.0/24`来说，`10.1.10.255` 是广播地址，向改地址发送消息相当于向其中所有主机发送消息。

还有一些地址，它们可以被分配，却不能被路由，即**私有地址**。私有地址是专门为内部网络使用而保留的地址范围，它们不会在互联网上进行路由。常见的私有地址包括：
- IPv4：10.0.0.0/8、172.16.0.0/12、192.168.0.0/16
- IPv6：fc00::/7

私有地址和上述的预留地址都是**不可路由的地址**。这些不可路由地址有助于隔离内部网络、提高安全性并防止地址冲突。如果尝试将这些地址用于公共互联网通信，通常会被路由器或防火墙丢弃，因为它们不是全球可路由的地址。

为了将一个较大的网络分出子网，我们引入了**子网掩码**，而为了更简单地描述子网网段，我们引入了**CIDR（Classless Inter-Domain Routing，无类别域间路由）** 来描述网络，取代了上述ABC类网络的划分。  
举个例子，网段`192.168.1.0/24`表示包含 256个连续的IPv4地址的子网（`192.168.1.0-192.168.1.255`），`/24`表示其前面24个bit是网络部分，后面8bit可用于分配主机IP，自然能很轻易地得出它的子网掩码是`255.255.255.0`

#### ICMP协议

**ICMP（Internet Control Message Protocol，互联网控制消息协议）** 协议是TCP/IP协议族的一部分，是IP协议的一个扩展和辅助，用于在IP网络中**传输控制消息**和**错误报告**。  
ICMP有自己的独立报文结构，比较简单：

```
    0                   1                   2                   3
	0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Type      |     Code      |            Checksum           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                         Message Data                          +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- **类型（Type）**：8bit，指定该ICMP报文的目的或功能，例如，Type=0表示回显回应（ping回应），Type=3表示目标不可达等。相当于HTTP状态码中的2XX（成功），4XX（客户端错误）等。
- **代码（Code）**：8bit，用于提供关于类型的更多细节。不同的Type和Code组合表示不同的消息子类型。例如，Type=3时，Code可以表示网络不可达、主机不可达等原因。相当于HTTP状态码中的200请求成功，404资源不存在等。
- **校验和（Checksum）**：16bit，计算整个ICMP消息的校验和，以确保消息在传输过程中没有被损坏，保证消息的完整性。
- **消息数据（Message Data）**：长度可变，根据消息类型和代码的不同而变化。

常见的消息类型和代码组合如下：

| 类型Type | 代码Code | 描述         |
| -------- | -------- | ------------ |
| 0        | 0        | Echo Reply   |
| 3        | 0        | 网络不可达   |
| 3        | 1        | 主机不可达   |
| 3        | 2        | 协议不可达   |
| 3        | 3        | 端口不可达   |
| 5        | 0        | 重定向       |
| 8        | 0        | Echo Request | 

当我们在命令行执行`ping`命令测试站点是否可达时，会发送ICMP**回送请求**和**应答报文**，目标站点收到回送请求后会把应答报文送回给我们，我们若能成功收到应答报文则说明该站点可达。   
下面的`icmp_seq`则表示我们发送的ICMP报文序列。

```
└─> ping www.baidu.com                      
PING www.a.shifen.com (153.3.238.110): 56 data bytes
64 bytes from 153.3.238.110: icmp_seq=0 ttl=53 time=18.499 ms
64 bytes from 153.3.238.110: icmp_seq=1 ttl=53 time=17.794 ms
64 bytes from 153.3.238.110: icmp_seq=2 ttl=53 time=16.846 ms
```

#### ARP协议

**ARP（Address Resolution Protocol，地址解析协议）** 用于在局域网（LAN）中将IP地址解析为物理硬件地址（通常是MAC地址）。

通常情况下，设备只知道目标的IP地址（在数据报文头部中），因此需要发送ARP请求来获取对应IP地址的MAC地址。**ARP请求**是一个**广播**，它会在局域网中询问“谁的IP地址是XXX，请告诉我你的MAC地址”；拥有指定IP地址的目标设备会响应ARP请求，将自己的MAC地址发送回请求设备，即**ARP响应**。  
此外，设备通常会维护一个**ARP缓存表**，其中存储了最近的IP到MAC地址映射信息。这可以减少ARP请求的频率，提高局域网通信的效率。同时为了及时感知网络的变更，保存的信息会在较短的时间内过期，需要再次发送广播请求。

ARP协议是工作在数据链路层（第二层）的协议，因为这时候需要目标设备的物理地址，只差临门一脚数据就送到了。但在这之前，当涉及到多个网络的时候，需要通过路由来在不同网络之间分发数据包。

#### 路由 Routing

路由是一个过程，表示在不同网络之间转发数据包的过程。它决定了数据包应该通过网络的哪个路径和下一个节点（路由器）进行传输，因此该过程发生在网络层（第三层）

当一个路由器接收到数据后，会从数据包中获取目标IP地址，并拿着这个IP地址去自己的**路由表**里查询这个IP地址要从哪个端口发出去。在这个过程中路由器会给数据封装一个新的报文，需要将原头部中的TTL字段减1，重新计算检验和等。

在Mac中可以通过`netstat -nr`命令来查看本机的路由表：

```
Routing tables

Internet:
Destination        Gateway            Flags           Netif Expire
default            10.209.23.254      UGScg             en0       
10.209.20/22       link#15            UCS               en0      !
10.209.20.54/32    link#15            UCS               en0      !
10.209.20.54       bc:d0:74:59:ed:f   UHLWI             lo0       
......
```

虽然不同设备的路由表会略有差别，但基本会包涵这几项：
- Destination：目标网络。路由器所有已知的网络会占一行，上述使用的是CIDR表示网络。如果不用CIDR一般会再多一列`Netmask`来表示子网掩码。
- Gateway：网关。表示下一跳设备的IP地址。如果数据包目标位于本地网络上，网关字段可能为空（直接路由）。
- Interface / Netif：下一跳接口。表示路由器找到目标网络后该要从哪个接口把数据送出去。
- Expire：表示路由表项的过期时间。它通常在动态路由协议中使用，用于指示路由表项何时将被丢弃。

#### 路由协议

按照内外网分，路由协议可分为：
- **IGP（Interior Gateway Protocol）**：内部网关协议。通常用在一个**自治系统（Autonomous System，AS）** 的内部，常见的是某实体下所有IP网络和路由器共享消息，如企业/组织/学校的内网。
- **EGP（Exterior Gateway Protocol）**：外部网关协议。EGP用于在不同自治系统（AS）之间传输路由信息，如 **BGP（Border Gateway Protocol）**

而IGP可进一步分为两类：
- **链路状态路由协议（Link State Routing Protocol）**：基于网络中的链路状态信息来计算路由表。每个路由器维护一个关于网络拓扑的全局视图，然后使用该信息来计算最短路径。如**OSPF**和**IS-IS**等协议。
- **距离矢量路由协议（Distance-Vector Protocol）**：用跳数或其他度量标准来决定最佳路径。每个路由器只知道到达目标网络的距离，而不了解整个网络的拓扑。如**RIP**和**EIGRP**等协议。

最简单的路由协议是**静态路由（Static Routing）**，由管理员明确指定每个网络的路由器和接口，它不能自主更新，每次网络变动都需要手动更改。  
因此，现代路由器设备通常都采用**动态路由协议**，这让路由器可以自主选择出最佳的可达路径，且不同路由器之间可以共享路由信息，不需要人为干预。  

- **OSPF协议（Open Shortest Path First）**：OSPF属于IGP，是一种链路状态路由协议，适用大中型网络。每个OSPF路由器都维护一个网络拓扑的全局视图，利用Dijkstra算法来计算最短路径树，并能在发生故障时重新计算新的最佳路径。此外，路由器还采用Hello协议和相邻路由器建立邻居关系，以便共享数据，更新链路状态。
- **RIP协议（Routing Information Protocol）**：RIP属于IGP，是一种距离矢量路由协议，适用于中小型网络。RIP使用跳数衡量路径的好坏，并每隔一段时间向相邻路由器广播路由信息，实现路径共享。存在RIPv1和RIPv2两种常见的版本。

### 传输层

第四层传输层提供了**可靠的端到端的数据传输服务**，确保数据可靠地从发送方传输到接收方。因为是端到端，所以需要建立连接；因为需要可靠传输，所以需要具备流量控制、错误重传等功能。或许咱不了解传输层，但是一定听过**TCP/UDP协议**的大名。

#### 端口号

由于传输层是端到端的通信，因此需要将数据从源端口发送到目标端口，这就需要系统指派对应的端口号来进行数据的收发。  
通常我们机子的端口分为**系统端口（Well-Known Ports，也称众所周知端口）** 、**已注册端口（Registered Ports）**、 **临时端口（Ephemeral Ports，也称动态端口或私有端口）**：

| 端口号        | 描述                                                                                |
| ------------- | ----------------------------------------------------------------------------------- |
| 0             | 不在网络连接中使用，通常用于告知操作系统随机选择一个端口                            |
| 1 - 1023      | 系统端口，通常为一些常用功能保留，如80为HTTP端口，21为FTP端口等                     |
| 1024 - 49151  | 已注册端口，用于标识用户自定义的应用程序或服务，如3306是Mysql，8080是Tomcat/JBoss等 |
| 49152 - 65535 | 临时端口，在TCP建立连接的时候会临时选用作为源端口（Source Port）                    | 

通常服务器会监听自己的某个已注册端口（自己先前就定义好了，这个端口负责监听这个服务），然后客户端在建立连接的时候给自己随机分配一个临时端口。  
理论上来说已注册端口也是一种临时端口，但是许多数据库服务（如MySQL3306）、游戏服务器等使用比较广泛，为了避免冲突，每个应用程序分配唯一的已注册端口号，以确保它们能够在同一主机上并行运行而不会干扰彼此。   
管理已注册端口号的分配通常由**IANA（Internet Assigned Numbers Authority）** 或其他类似的机构负责。开发人员可以向这些机构申请特定端口号的分配，以便在应用程序中使用。

#### TCP协议

**TCP（Transmission Control Protocol，传输控制协议）** 是一种面向连接的协议，提供可靠的数据传输。它负责两端连接的建立和维护，检测并重传丢失的数据包，以及进行流量控制。TCP适用于那些要求数据完整性和可靠性的应用，如Web浏览、电子邮件传输等。  
由于TCP可以将数据包分割成合适大小的块（Segment），其流量控制和拥塞控制机制都是基于这些块来操作，因此它实际上是一种**面向流的协议**，它将数据视为字节流。

当我们把IP报文中的IP头部去掉，剩下的就是TCP报文了。TCP也包含**报文头部**和**数据部分**，这里看一下头部的结构：

![TCP Segment Header](https://z1.ax1x.com/2023/09/15/pPW4m26.png)

- 源端口号（Source Port）：16bit，发送端应用程序的端口号。
- 目的端口号（Destination Port）：16bit，接收方应用程序的端口号。
- 序列号（Sequence Number）：32bit，标识数据在传输序列中的位置，用于对数据排序和重组
- 确认号（Acknowledgment Number）：32bit，当ACK标志位被设置时才会包含，即三次握手时的ACK确认号。表示期望接收的下一个数据段的序列号，用于确认已经接收到的数据。
- 数据偏移（Data Offset）：也称头部长度（Header Length）。表示数据部分在TCP报文的起始位置，因此也可以比哦啊是TCP头部大小（因为有可选字段，所以头部大小不一）
- 保留位（Reserved）：6bit，保留不用，目前应设置为零
- 标志位（Flags）：6bit，每个bit都为一个标志，用于控制和管理TCP连接。
- 窗口大小（Window Size）：16bit，表示自己的接收窗口大小，用于流量控制。
- 校验和（Checksum）：16bit，用于检测报文是否在传输过程中发生了损坏。
- 紧急指针（Urgent Pointer）：仅在URG标志被设置时才包含，表示数据部分含有紧急数据，该指针标识了紧急数据的最后一个字节的位置。
- 可选字段（Options）：长度可变，包含一些额外信息如最大报文段长度（Maximum Segment Size，MSS）、窗口扩大因子、时间戳等。

TCP使用**拥塞窗口控制**的机制来进行流量控制，即在发送数据之前先和对方协商一个窗口大小（滑动窗口，即缓冲区），并在数据发送的过程中根据这个窗口动态调整发送速度，同时这个窗口的大小也可以根据网络条件和收发能力动态调整，以免造成网络拥堵。      
当TCP连接刚建立时，发送方会采用**慢启动（Slow Start）算法**，窗口的初始大小很小，但每收到一次确认应答之后就会指数增长（2、4、8、16...），直到达到一个**拥塞避免阈值**。之后会从指数增长转为线性增长，每次收到确认应答只增加一个**MSS（最大报文长度）**，这一阶段称为**拥塞避免**。  
当发生拥塞时，发送方需要降低发送速率，减小窗口的值并减半阈值，即**拥塞控制**。当拥塞结束后，在重新进入慢启动和拥塞避免状态。

#### 三次握手和四次挥手

先放个TCP的控制标签在这，对应头部的标志位（Flags）：

| 标签                  | 描述                                                                   |
| --------------------- | ---------------------------------------------------------------------- |
| URG（Urgent）         | 表示当前数据非常重要，且头部紧急指针字段包含紧急数据的末尾位置         |
| ACK（Acknowledgment） | 表示头部的确认号字段包含有效，其在建立连接后的数据传输中通常都被设置。 |
| PSH（Push）           | 表示接收方应尽快将数据交给应用程序，而不是放在缓冲区等待               | 
| RST（Reset）          | 表示重置连接，立即终止当前连接                                         |
| SYN（Synchronize）    | 用于建立连接，常与ACK标志一起用于握手建立连接                          |
| FIN（Finish）         | 表示结束连接，希望关闭TCP连接                                          |

再放个TCP的套接字状态在这，表示连接两端的端口状态：

| 状态         | 描述                                                                                   |
| ------------ | -------------------------------------------------------------------------------------- |
| LISTEN       | 端口空闲，准备就绪，可以进入连接状态（只在服务器出现）                                 |
| SYN_SENT     | 给服务器发送了SYN连接请求，但还没收到回复（只在客户端出现）                            |
| SYN_RECIEVED | 收到了来自客户端的请求，并给回复了确认报文，但还没收到确认报文的回复（只在服务器出现） |
| ESTABLISHED  | 连接成功建立，可以自由互发数据                                                         |
| FIN_WAIT     | 发送了FIN请求，但还没收到ACK回复                                                       |
| TIME_WAIT    | 一定时间（常为2倍的最大段寿命）后自动变为CLOSED，用以等待延迟或数据                    |
| LAST_ACK     | 服务器发送了FIN请求，还没收到回复（只在服务器出现）                                    |
| CLOSE_WAIT   | 传输层TCP连接关闭，等待释放                                                            |
| CLOSED       | TCP连接完全关闭                                                                        |

**三次握手（Three-Way Handshake）** 是TCP建立连接的过程，至少要两端经过三次数据传递才能让双方确保自己和对方都已经建立连接、准备传输数据了。

1. 客户端向服务器发送一个TCP报文（**SYN**），其包含：
	1. 客户端的初始序列号（Sequence Number）
	2. 设置**SYN标志位**，表示我要建立连接
	3. 客户端的端口状态从**CLOSED**变为**SYN_SENT**，等待服务器确认
2. 服务器收到SYN报文，进行回复（**SYN-ACK**），回复报文包含：
	1. 服务器的初始序列号（Sequence Number）
	2. 设置**ACK和SYN标志位**，表示我收到了你的连接请求，且我也要建立连接
	3. 将客户端的序列号+1
	4. 端口状态从**LISTEN**变为**SYN_RECIEVED**，开始监听客户端的连接请求
3. 客户端收到SYN-ACK报文，发送最后的确认应答报文（**ACK**）给服务器：
	1. 设置**ACK标志位**，表示我收到了你的连接请求
	2. 将服务器的序列号+1
	3. 客户端的端口状态从**SYN_SENT**变为**ESTABLISHED**，表示连接已建立

服务器收到客户端的ACK报文后，端口状态变为**ESTABLISHED**，连接建立完成，双方可以开始安全地进行数据传输。

**四次挥手（Four-Way Handshake）** 过程用于确保通信的双方都已完成数据传输，可以安全地关闭连接。至少需要四次数据传递才能确保双方的端口都关闭，资源得到释放。避免一方已经结束连接，另一方还在傻傻等待的冤种情况出现。

1. 客户端决定结束连接，向服务器发送一个TCP报文（**FIN**）：
	1. 设置**FIN标志位**，表示我要结束连接，不再发送数据
	2. 序列号字段包含最后一个字节的序列号
	3. 客户端的端口状态从**ESTABLISHED**变为**FIN_WAIT_1**
2. 服务器收到客户端的FIN报文，发送一个回复报文（**ACK**）：
	1. 设置**ACK标志位**，表示收到了你的结束请求
	2. 将客户端的序列号+1
	3. 进入**CLOSE_WAIT**状态
	客户端收到服务器的ACK确认报文：
	1. 端口状态从**FIN_WAIT_1**变为**FIN_WAIT_2**
	2. 等待服务器的结束请求（FIN）
3. 服务器接着进行一些操作（如释放资源等），准备好结束连接后，向客户端发送报文（**FIN**）：
	1. 设置**FIN标志位**，表示我也要结束连接，不再发送数据
	2. 序列号字段包含服务器最后一个字节的序列号
	3. 服务器的端口状态从**CLOSE_WAIT**变为**LAST_ACK**
4. 客户端收到服务器的FIN报文，发送一个回复报文（**ACK**）：
	1. 设置**ACK标志位**，表示收到了你的结束请求
	2. 将服务器的序列号字段+1
	3. 端口状态从**FIN_WAIT_2**变为**TIME_WAIT**，并在一段时间后变为**CLOSED**

最后服务器收到了来自客户端的ACK报文，端口状态从**LAST_ACK**变为**CLOSED**，连接正式结束。

![States Change](https://z1.ax1x.com/2023/09/15/pPWITv6.png)

#### UDP协议

**UDP（User Datagram Protocol，用户数据报协议）** 是一种无连接的协议，提供了一种轻量级的数据传输服务。它的传输速度更快，但不提供数据可靠性，因此不会建立连接、不会进行错误检测或重传。UDP适用于那些对数据丢失或顺序不敏感的应用，如音频/视频流传输、在线游戏等。   
和TCP不同，UDP是一种**面向消息的协议**。它不提供数据分割或重新组装的机制，如果发送的消息大于UDP的最大包大小，就会导致数据不完整而出错，需要应用程序在发送数据前自行对数据进行切割重组。

**无连接**意味着UDP在数据传输之前不需要建立连接，也不需要维护连接状态。因此每个UDP数据包都是独立的。我只管自己发送数据，至于你收没收到那就不关我的事了。  
因为UDP**不提供可靠性保证**，它不执行数据包的确认、重传、流量控制或拥塞控制，因此在网络传输中数据包有可能丢失、重复或到达的顺序不正确。  
但也因此UDP报文的头部较小，开销较低，传输速度更快，更适合用于实时应用程序。

### 应用层

在TCP/IP模型中，应用层包含了原OSI模型的三层模型，因此也包含了**管理通信连接（会话层）**、**数据格式转换（表示层）**、**主机交互（应用层）** 的功能  
由于应用层**向应用程序提供网络接口，直接向用户提供服务**，因此协议都比较常见，对应的功能也十分明确。比如POP3和SMTP用来收发邮件、FTP用于文件传输、HTTP\[S\]用于访问网页等。简单来说，有端口号的协议都可以算是应用层协议。

应用层协议主要有两种通信方式：
- **CS类型，即客户端-服务器类型（Client-Server）**：这种类型用的比较广泛，大多数应用层协议用的都是这种类型。提供服务的服务器公开固定IP地址，并始终保持监听；而客户端通过请求服务器来获取服务，客户端和客户端之间无感知，不会互相通信。
- **P2P类型，即点对点类型（Peer-to-Peer）**：没有特定的服务器/客户端，或者说每个人都可以是服务器或客户端。只要安装了应用程序，可以在主机之间建立对等连接，既可以提供服务，也可以接受服务，通常是⼤流量的应⽤程序采⽤ P2P 模型，比如下载器（迅雷怎么说迅雷）。  还有一些游戏的联机采用的是P2P类型，好处是很省钱（官方不用自己租服务器了，但是好像省的不是我的钱？），坏处是连接很不稳定，只有房主自己嘎嘎流畅，其他人的连接稳定性参差不齐。

开发应⽤程序时，可以使⽤现有的应⽤协议，也可以定义⼀个新的协议。同时，应⽤程序可以直接使⽤传输层以下的⽹络传输服务，开发者只需要关⼼选择哪种应⽤协议、如何开发即可，不⽤考虑数据是如何传输到⽬的地。这也是 TCP/IP 模型的好处之一。

#### SSH协议

**SSH（Secure SHell，安全外壳协议）** 通过**加密**来提供安全的远程登录功能的服务，加密后的敏感信息（如账号密码等）即使被中途截获，也无法解密，无法还原出真正的内容。

目前使用比较广泛的SSH协议版本是SSHv2，默认使用TCP 22端口。  
SSH客户端向SSH服务器发出连接请求，两者先协商确定使用的SSH版本。然后进行身份验证（密码验证、公钥验证、证书验证等方式），其中**公钥验证方式**是最常用的，它基于密钥对，客户端和服务器之间交换公钥和签名以验证身份。  
身份验证成功后，两者之间生成一个会话密钥，用于后续数据的加解密。此外，为了保护数据的完整性，SSH还使用**MAC（Message Authentication Code，消息认证码）** 来保护数据的完整性（和数据链路层的MAC不是一个东西）。MAC通过对数据进行哈希计算生成，接收端使用相同的密钥和算法来验证数据是否被篡改。

#### FTP协议

**FTP（File Transfer Protocol，文件传输协议）** 是一种用于在计算机之间传输文件的标准网络协议。它采用客户端-服务器模式，并使用TCP协议提供可靠传输。FTP 可以进行用户名/密码的验证，允许指定⽂件的传输类型，可以设置⽂件的传输权限。

FTP 使⽤**两条 TCP 连接**实现⽂件传输：
1. **控制连接**的FTP：用于传输FTP控制命令和应答消息，如用户名/密码的验证、文件名称、发送方式的设置。它在整个FTP会话过程中会一直保持开启，通过**ASCII码**进行收发应答。使用TCP 21端口。
2. **数据连接**的FTP：用于文件数据的传输，仅在需要时建立连接，传输完成后关闭连接。通常使用TCP 20端口（可以修改，也可以有多个端口）。

在传输文件数据的时候，为了应对不同操作系统的不同存储方式，有两种方式可供选择：
1. **ASCII模式**：默认模式，发送方将本地文件转换为标准ASCII码进行传输；接收方收到后根据自己的存储方式将结果转为可读的本地文件。该模式常用于传输文本文件。
2. **二进制流模式**：也称图像文件传输模式。发送方将文件按照比特流进行传输，不做任何转换。常用于传送程序文件。

此外，FTP的数据连接根据**服务器主动或被动建立连接**，可以分为**主动模式**和**被动模式** ：
1. **主动模式（Active Mode）** ：也称**PORT⽅式**。该模式下客户端会向服务器发送PORT命令，其中带有主机IP地址、数据传输的临时端口号等消息。当需要传输数据时，**服务器**通过这些消息**主动**发起连接，建立传输通道。
2. **被动模式（Passive Mode）**：也称**PASV方式**。客户端向服务器发送PASV命令，服务器选择临时端⼝号并告知客户端。当需要传输数据时，**客户端**根据这些信息**主动**建⽴通道进行数据传输。

对于客户端来说，由于**主动模式**下自己给服务器的临时端口号是不确定的，自己的防火墙并不知道“这个端口被用来FTP了”，因此通常会阻止这种外部主机（FTP服务器）对自己未知端口的访问，因此常用**被动模式来穿越防火墙**。

要注意的是，原始的FTP是不提供加密的，数据可能被窃听。于是有了**FTP over TLS（FTPS）** 或 **SFTP（SSH File Transfer Protocol）** 等安全的FTP变种，它们提供了加密和身份验证功能，增加安全性。

#### 电子邮件

原始的电子邮件架构比较简单，直接从发送方电脑发送到接受方电脑，但这种方式需要确保双方都在线。
如今的电子邮件架构演变为：`发送方电脑->发送方邮件服务器->接收方邮件服务器->接收方电脑`。这个架构中，邮件发送⽅和接收⽅电脑（或电子邮件应用，如Gmail、Outlook等）称为**⽤户代理**。用户代理允许用户创建、发送、接收、查看、组织和管理电子邮件并与邮件服务器通信，通过协议（如SMTP、IMAP、POP3）发送和接收邮件。

使用电子邮件需要一个地址，即**邮件地址**或**邮箱地址**，比如：`blackdn@qq.com`  
前面的`blackdn`表示用户名称，`@`是分隔符，后面的`qq.com`相当于通信地址，在同一个通信地址内用户名称必须是唯一的。  
通过通信地址我们可以得知，`http://qq.com`是邮件接收服务器的域名。但是我们知道`http://qq.com`是企鹅最官方的域名，怎么可能拿出来只用于邮件收发呢？实际上，由于电⼦邮件的发送地址由DNS管理，其中注册了邮件地址和对应邮件服务器的域名，即**MX记录（Mail Exchange）** ，而`http://qq.com`的 MX 记录指向`http://mail.qq.com`，因此任何发送给 `http://qq.com` 邮件都被转到 `http://mail.qq.com` 服务器。所以实际上这里有个重定向的过程，真正用到的是`http://mail.qq.com`。

#### SMTP协议

**SMTP（Simple Mail Transfer Protocol）** 定义了**发送**电子邮件的规则和标准。通常`发送方用户代理->发送方服务器`和`发送方服务器->接收方服务器`使用的就是SMTP协议。因此也可以说SMTP是**邮件服务器接收邮件的协议**。

SMTP基于TCP协议，使用25号端口。其过程比较简单，用一张图来说明：  
要注意的是其中的[SMTP 状态码](https://en.wikipedia.org/wiki/List_of_SMTP_server_return_codes)是SMTP自己定义的，要和HTTP的状态码进行区分

![SMTP Progress](https://z1.ax1x.com/2023/09/18/pP4nVYT.png)


不过还是存在一些缺陷：
1. 邮件以**明文形式传输**，没有加密措施
2. **没有认证机制**，攻击者可以伪造发件人的邮件地址  
为了解决这些问题，推出了**扩展的SMTP（ESMTP，Extended SMTP）**，其提供了认证和加密等功能，还有一些扩展头部和扩展命令，提高电子邮件传输的可靠性、安全性和功能性。

#### POP3协议

通过SMTP协议，邮件从发送方代理来到了接收方服务器。由于个人电脑不可能永远开机，而我们希望能一开机就收到邮件，这个功能是SMTP不支持的，因此就要引入新的协议。

**POP3（Post Office Protocol version 3）** 是一种用于**接受电子**邮件的协议。它从邮件服务器下载电子邮件到本地客户端，以便用户可以阅读、管理和存储邮件。此外它是一种**单向通信协议**，只用于接收邮件，不支持向服务器发送邮件或将邮件保留在服务器上。   
它同样基于TCP协议，使用110端口连接服务器，进⾏⽤户认证（防止伪装用户盗取邮件内容）、邮件列表查询、邮件下载、邮件删除等操作，操作完成后断开 TCP 连接。

由于POP3在传输过程中不提供加密，存在被窃听的风险。因此可以使用**POP3S（POP3 Secure）** 协议，它在通信过程中使用SSL/TLS加密邮件内容。

#### IMAP协议

上面说道，POP3协议不能将邮件保留在服务器上，这会导致多设备上的不同步，比如在一个设备上标记邮件已读或删除邮件，都不会同步到其他设备上。

因此，现在更多使用**IMAP（Internet Message Access Protocol，互联网邮件访问协议）协议** 来取代POP3。  
IMAP将电子邮件保留在服务器上，不进行下载，因此在任何设备上访问到的邮件状态都是相同的。其还会在服务器上对 “ 已读/未读 ” 信息和邮件分类管理，因此允许用户在不同设备上访问和同步邮件

#### URI、URL和HTTP\[S\]协议

最后准备看一下HTTP协议，不过在这之前我们看一下URI和URL的结构：

- **URI（Uniform Resource Identifier）**：由某个协议⽅案表⽰的定位资源的标识符，是将⼀个资源与另⼀个资源区分开的字符串标识方法。比如我们熟悉的URL地址通常就是采用HTTP协议标识资源的URI。
- **URL（Uniform Resource Locator）**：是URI的一种具体形式，它用于描述**互联网资源**（网页、图像等）的位置。

![URL Structure](https://z1.ax1x.com/2023/09/19/pP4fU2t.png)

URL由以下部分组成:
- **协议（protocol）**：指定用于访问资源的协议，如HTTP、HTTPS、FTP等。
- **主机名或IP地址（host）**：指定资源所在的服务器的主机名或IP地址。
- **端口号（port）**：指定服务器上用于访问资源的端口号（可选，默认为协议的默认端口）。
- **资源路径（path）**：指定资源在服务器上的路径。
- **查询字符串（query/search）**：包含附加参数的字符串，用于传递给资源的请求。
- **片段标识符（fragment/hash）**：指定资源中的特定片段或锚点。

**HTTP（Hypertext Transfer Protocol，超文本传输协议）** 是一种用于在互联网上传输超文本（Hypertext）数据的协议，用于在Web客户端（浏览器）和Web服务器之间传输数据。当我们在浏览器中输入网址之后，HTTP就开始工作了，它默认在服务器的80端口上建立TCP连接。  

由于HTTP是一种**无状态协议**，它不保留客户端和服务器之间的会话状态或上下文信息（因此需要`Cookie`和`Session`来跟踪用户状态状态），每个请求都是独立的。   
于是在`HTTP/1.0`版本中，每一个命令和应答都会进行一次TCP的连接和断开，但是频繁的连接和断开降低了效率。因此`1.1`进行了改进，允许一个TCP连接中发送多个命令和应答，即**保持连接（keep-alive）**。而在`HTTP/2.0`版本中引入二进制、多路复用等特性，进一步提高传输效率。  

HTTP不提供加密，因此数据可以在传输过程中被窃听。为了增加安全性，现在广泛使用**HTTPS（HTTP Secure）协议**。  
HTTPS使用**TLS（Transport Layer Security）** 或其前身**SSL（Secure Sockets Layer）** 进行数据加密。为了启用HTTPS，网站所有者需要获得由受信任的**证书颁发机构（Certificate Authority，CA）** 签发的数字证书。CA会验证网站的身份，然后签发证书，用户的浏览器可以验证证书的有效性。  
当服务器收到HTTPS连接请求后，会从支持的加密算法中选择一个用于安全通信的加密套件，该套件包括加密算法、密钥交换协议和消息验证算法。然后服务器将自己的数字证书发送给客户端。数字证书包括服务器的公钥、证书有效期和CA签名，客户端能以此验证服务器的身份。  
如果验证失败，浏览器会阻止访问并发出警告；如果成功，客户端会生成一个**随机对称密钥（Session Key）** 用于加密和解密数据（和SSL的流程一样）。

#### 附录：基于TCP / UDP的协议

基于TCP的协议：
- HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。
- HTTPS（Hypertext Transfer Protocol over Secure Socket Layer, or HTTP over SSL，安全超文本传输协议），HTTP协议的安全版本。
- FTP（File Transfer Protocol，文件传输协议），由名知义，用于文件传输。
- POP3（Post Office Protocol, version 3，邮局协议），收邮件用。
- SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。
- TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。
- SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。

基于UDP的协议：
- BOOTP（Boot Protocol，启动协议），应用于无盘设备。
- NTP（Network Time Protocol，网络时间协议），用于网络同步。
- DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。
- DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作（运行在TCP和UDP协议上）。
- ECHO（Echo Protocol，回绕协议），用于查错及测量应答时间（运行在TCP和UDP协议上）。
- SNMP（Simple Network Management Protocol，简单网络管理协议），用于网络信息的收集和网络管理。
- ARP（Address Resolution Protocol，地址解析协议），用于动态解析以太网硬件的地址。

## 参考

1. [Wikipedia - OSI Modal](https://en.wikipedia.org/wiki/OSI_model)
2. [Wikipedia - Internet protocol suite](https://en.wikipedia.org/wiki/Internet_protocol_suite)
3. [How Do You Know if a MAC Address is a Unicast, Multicast or Broadcast MAC address](https://tooabstractive.com/networking/how-do-you-know-if-a-mac-address-is-unicast-multicast-or-broadcast/)
4. [Introduction and IPv4 Datagram Header](https://www.geeksforgeeks.org/introduction-and-ipv4-datagram-header/)
5. [Wikipedia - Transmission Control Protocol](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)
6. [Transmission Control Protocol (TCP)](https://www.khanacademy.org/computing/computers-and-internet/xcae6f4a7ff015e7d:the-internet/xcae6f4a7ff015e7d:transporting-packets/a/transmission-control-protocol--tcp)
7. [Wikipedia - List of SMTP server return codes](https://en.wikipedia.org/wiki/List_of_SMTP_server_return_codes)
8. 感谢ChatGPT